<div align="center">
    <img src=".github/logo_alt.png" alt="Walrus Logo" width="200">
    <h1>ü¶≠ Walrus Programming Language</h1>
</div>

A fast, expressive programming language with a clean syntax and powerful features, built in Rust.

## Overview

Walrus is a dynamically-typed, interpreted programming language that combines simplicity with power. It features both a tree-walking interpreter and a **bytecode virtual machine** for efficient execution, along with a **mark-and-sweep garbage collector** and comprehensive support for modern programming paradigms.

## Key Features

### Dual Execution Modes

- **Bytecode VM**: High-performance stack-based virtual machine with call frames and tail call optimization
- **Tree-Walking Interpreter**: Direct AST interpretation for development and debugging
- **Disassembler**: Inspect generated bytecode and analyze program structure

### Language Features

- **First-Class Functions**: Functions as values with nested function support
- **Structs & Methods**: Object-oriented programming with struct definitions and static methods
- **Comprehensive Data Types**: integers, floats, strings, booleans, lists, tuples, dictionaries, ranges
- **Control Flow**: if/else conditionals, while loops, for loops with iterators, break/continue
- **Format Strings**: Embedded expressions within string literals (f-strings)
- **Short-Circuit Evaluation**: Optimized boolean logic with `and`/`or` operators
- **Recursion**: Full support for recursive functions with tail call optimization
- **String Manipulation**: Slicing, indexing, and string operations
- **Collection Operations**: List/dict concatenation, negative indexing, in-place modification

### Virtual Machine Architecture

- **Stack-Based Execution**: Efficient push/pop operations for expression evaluation
- **Call Frame Stack**: Proper function call semantics with frame pointers (not child VMs)
- **Shared Locals Vector**: Memory-efficient local variable storage across frames
- **Tail Call Optimization**: `TailCall` opcode reuses frames for recursive functions
- **80+ Opcodes**: Comprehensive instruction set including specialized zero-operand variants

### Compiler Optimizations

- **Constant Folding**: Arithmetic and boolean expressions evaluated at compile time
- **Specialized Opcodes**: `LoadConst0`, `LoadLocal0-3`, `LoadGlobal0-3` for common indices
- **Stack Operations**: `Dup`, `Swap`, `Pop2`, `Pop3` for efficient manipulation
- **Memory-Optimized**: u32 indices reduce instruction size from 16 to 12 bytes
- **Forward Declaration**: Two-pass compilation for mutual recursion support

### Memory Management

- **Mark-and-Sweep GC**: Automatic garbage collection with configurable thresholds
- **Arena Allocation**: Separate `DenseSlotMap` arenas for each heap type
- **Memory Tracking**: Byte-level allocation tracking triggers GC intelligently
- **String Interning**: Via `strena` for deduplicated string storage
- **Custom Allocator**: `mimalloc` for improved allocation performance

### Built-in Functions

| Function              | Description                         |
| --------------------- | ----------------------------------- |
| `len(x)`              | Get length of string, list, or dict |
| `str(x)`              | Convert value to string             |
| `type(x)`             | Get type name of a value            |
| `input(prompt)`       | Read user input with prompt         |
| `__gc__()`            | Manually trigger garbage collection |
| `__heap_stats__()`    | Get heap statistics as a dict       |
| `__gc_threshold__(n)` | Configure GC allocation threshold   |

### Standard Library

Walrus provides a standard library through an import system. Modules are imported using the `import` statement and return a dictionary of functions.

```walrus
import "std/io";
import "std/sys" as system;
```

#### `std/io` - File I/O Operations

| Function                         | Description                                                       |
| -------------------------------- | ----------------------------------------------------------------- |
| `io.file_open(path, mode)`       | Open a file, returns a handle. Modes: `"r"`, `"w"`, `"a"`, `"rw"` |
| `io.file_read(handle)`           | Read entire file contents as string                               |
| `io.file_read_line(handle)`      | Read a single line (returns `nil` at EOF)                         |
| `io.file_write(handle, content)` | Write string to file, returns bytes written                       |
| `io.file_close(handle)`          | Close a file handle                                               |
| `io.file_exists(path)`           | Check if a file exists (returns bool)                             |
| `io.read_file(path)`             | Convenience: read entire file in one call                         |
| `io.write_file(path, content)`   | Convenience: write entire file in one call                        |

**Example: File Operations**

```walrus
import "std/io";

// Simple read/write (convenience functions)
io.write_file("hello.txt", "Hello, Walrus!");
let content = io.read_file("hello.txt");
println(content);  // Hello, Walrus!

// Handle-based operations (for larger files or streaming)
let handle = io.file_open("data.txt", "w");
io.file_write(handle, "Line 1\n");
io.file_write(handle, "Line 2\n");
io.file_close(handle);

// Reading with handles
let reader = io.file_open("data.txt", "r");
let line = io.file_read_line(reader);
while line != nil {
    println(line);
    line = io.file_read_line(reader);
}
io.file_close(reader);
```

#### `std/sys` - System Operations

| Function            | Description                                         |
| ------------------- | --------------------------------------------------- |
| `sys.env_get(name)` | Get environment variable (returns `nil` if not set) |
| `sys.args()`        | Get command line arguments as a list                |
| `sys.cwd()`         | Get current working directory                       |
| `sys.exit(code)`    | Exit the program with the given status code         |

**Example: System Information**

```walrus
import "std/sys";

// Environment variables
let home = sys.env_get("HOME");
if home != nil {
    println(f"Home directory: {home}");
}

// Command line arguments
let args = sys.args();
println(f"Program: {args[0]}");
if len(args) > 1 {
    println(f"Arguments: {args[1..]}");
}

// Current directory
println(f"Working directory: {sys.cwd()}");

// Exit with status
if len(args) < 2 {
    println("Usage: walrus script.walrus <args>");
    sys.exit(1);
}
```

### Developer Experience

- **REPL Mode**: Interactive shell for rapid prototyping
- **Debugger Support**: Breakpoints, step-through execution, and stack inspection
- **Stack Traces**: Human-readable call stack on errors (truncated for deep recursion)
- **Comprehensive Error Messages**: Detailed error reporting with source locations
- **Benchmark Suite**: 20+ benchmarks comparing against Python

### JIT Compilation (Optional)

Walrus includes an optional **Just-In-Time (JIT) compiler** powered by [Cranelift](https://cranelift.dev/) that can dramatically speed up hot loops by compiling them to native machine code.

#### Performance

| Benchmark                     | Interpreter | JIT   | Speedup  |
| ----------------------------- | ----------- | ----- | -------- |
| 10K iterations √ó sum(0..1000) | 0.68s       | 0.01s | **~68x** |

#### Building with JIT Support

```bash
# Build with JIT feature enabled
cargo build --release --features jit

# Or add to your Cargo.toml
[features]
jit = ["cranelift-codegen", "cranelift-frontend", "cranelift-jit", "cranelift-module", "cranelift-native"]
```

#### Using the JIT

```bash
# Run with JIT enabled
./target/release/walrus program.walrus --jit

# Show JIT profiling statistics
./target/release/walrus program.walrus --jit --jit-stats

# Disable profiling (baseline comparison)
./target/release/walrus program.walrus --no-jit-profile
```

#### What Gets JIT Compiled

The JIT compiler targets **hot integer range loops** that follow specific patterns. A loop becomes "hot" after 1000 iterations.

**‚úÖ JIT-Compatible Patterns:**

```walrus
// Pattern 1: Sum accumulation (acc += i)
let sum = 0;
for i in 0..n {
    sum = sum + i;
}

// Pattern 2: Simple iteration with reassignment
let result = 0;
for i in 0..n {
    result = result + some_value;
}

// Pattern 3: Count iterations
let count = 0;
for _ in 0..n {
    count = count + 1;
}

// Pattern 4: Simple println of loop variable
for i in 0..n {
    println(i);  // Single println of integer is JIT-compiled
}

// Pattern 5: Sum with println
let sum = 0;
for i in 0..n {
    sum = sum + i;
    println(i);  // Can be combined with accumulation
}
```

**‚ùå NOT JIT-Compatible (falls back to interpreter):**

```walrus
// Function calls inside loop
for i in 0..n {
    result = compute(i);  // Contains Call opcode
}

// Multiple print operations per iteration
for i in 0..n {
    print(i);     // Multiple prints = not JIT-compatible
    print(" ");   // String printing not yet supported
}

// Complex operations (method calls, string ops, etc.)
for i in 0..n {
    list = list + [i];  // Complex heap operations
}
```

#### How It Works

1. **Hot-Spot Detection**: The VM profiles loop iterations and function calls
2. **Type Analysis**: Tracks runtime types to ensure type stability
3. **Bytecode Analysis**: Examines loop body for JIT-compatible operations
4. **Native Code Generation**: Uses Cranelift to compile to native machine code
5. **External Callbacks**: Print operations call back into Rust for I/O
6. **Seamless Execution**: JIT code reads/writes the same local variables as the interpreter

**Example JIT Output (with `--jit-stats`):**

```
Hot-spot Statistics:
  Total tracked regions: 3
  Hot loops: 1
  Hot functions: 1
  JIT compiled regions: 1
  Hottest spot: loop@5..5 (402000x)

Type Profile: 4 locations observed
JIT Stats: 1 functions compiled
```

#### Generated Native Code

For a simple sum loop, the JIT generates optimized native code:

```
// Walrus: for i in 0..n { sum = sum + i; }
// Cranelift IR:
block1(i, acc):
    cmp i < end
    branch to body or exit
block2:
    acc = acc + i
    i = i + 1
    jump block1
block3:
    return acc
```

## Installation

### Prerequisites

- [Rust](https://www.rust-lang.org/tools/install) (latest stable version)

### Build from Source

```bash
git clone https://github.com/sb2bg/walrus.git
cd walrus
cargo build --release
```

### Run

```bash
# Execute a file
cargo run -- file.walrus

# Start REPL
cargo run

# Compile mode (VM execution)
cargo run -- -c file.walrus

# Disassemble bytecode
cargo run -- -d file.walrus

# View help
cargo run -- --help
```

## Quick Start

### Hello World

```walrus
println("Hello, World!");
```

### Comments

Walrus supports both single-line and multi-line comments:

```walrus
// This is a single-line comment

/* This is a multi-line comment
     that can span multiple lines */

let x = 42; // Comments can appear after code

/* Multi-line comments can also be inline */ let y = 84;
```

### Variables & Types

```walrus
let number = 42;
let pi = 3.14159;
let name = "Walrus";
let active = true;
let items = [1, 2, 3, 4, 5];
let data = {"key": "value", "count": 10};
```

### Format Strings

```walrus
let name = "Alice";
let age = 30;
let score = 95.5;

// Basic interpolation
println(f"Hello, {name}!");

// Multiple expressions
println(f"User: {name}, Age: {age}");

// Arithmetic expressions
println(f"Next year you'll be {age + 1}");

// Complex expressions
let items = [1, 2, 3];
println(f"List has {len(items)} items: {items}");
println(f"Score: {score * 100 / 100}%");
```

### Functions

```walrus
fn factorial : n {
        if n <= 1 {
                return 1;
        }
        return n * factorial(n - 1);
}

let result = factorial(5);  // 120
```

### Anonymous Functions

```walrus
let square = : x {
        return x * x;
};

let result = square(7);  // 49
```

### Structs

```walrus
struct Point {
        fn new : x, y {
                return {"x": x, "y": y};
        }

        fn distance : p1, p2 {
                let dx = p1["x"] - p2["x"];
                let dy = p1["y"] - p2["y"];
                return (dx * dx + dy * dy) ** 0.5;
        }
}

let p1 = Point.new(3, 4);
let p2 = Point.new(0, 0);
let dist = Point.distance(p1, p2);  // 5.0
```

### Control Flow

```walrus
// Conditionals
if score >= 90 {
        println("A");
} else if score >= 80 {
        println("B");
} else {
        println("C");
}

// While loop
let i = 0;
while i < 5 {
        println(i);
        i = i + 1;
}

// For loop with range
for x in 0..10 {
        println(x);
}

// For loop with list
for item in [1, 2, 3, 4, 5] {
        println(item);
}
```

### FizzBuzz Example

```walrus
for n in 1..101 {
        let result = "";

        if n % 3 == 0 {
                result += "Fizz";
        }

        if n % 5 == 0 {
                result += "Buzz";
        }

        if result == "" {
                result = n;
        }

        println(result);
}
```

### Quicksort Example

```walrus
fn quicksort : arr {
        if len(arr) <= 1 {
                return arr;
        }

        let pivot = arr[0];
        let less = [];
        let equal = [];
        let greater = [];

        for x in arr {
                if x < pivot {
                        less = less + [x];
                } else if x == pivot {
                        equal = equal + [x];
                } else {
                        greater = greater + [x];
                }
        }

        return quicksort(less) + equal + quicksort(greater);
}

let sorted = quicksort([64, 34, 25, 12, 22, 11, 90, 88]);
```

## Architecture

### Virtual Machine

The Walrus VM is a stack-based bytecode interpreter with proper call frames:

- **80+ Opcodes**: Comprehensive instruction set for all language features
- **Call Frame Stack**: Each function call pushes a frame with return address, frame pointer, and bytecode reference
- **Shared Locals Vector**: All frames share a single locals vector, indexed by frame pointer + local index
- **Global Variables**: Stored in `Rc<RefCell<Vec<Value>>>` for cross-frame persistence
- **Tail Call Optimization**: Recursive tail calls reuse the current frame instead of pushing new ones
- **Automatic GC**: Collection triggered by allocation count or memory threshold

### Bytecode Compiler

- **Two-Pass Compilation**: Forward declarations for mutual recursion support
- **Constant Folding**: Evaluates `1 + 2 * 3` at compile time
- **Jump Patching**: Forward references resolved after compilation
- **Loop Context Tracking**: Break/continue with proper local cleanup
- **Scope Management**: Depth tracking distinguishes local vs. global variables
- **Symbol Tables**: Separate tracking for locals and globals with indices

### Garbage Collector

The mark-and-sweep GC traces from roots and frees unreachable objects:

- **Root Collection**: Stack, locals, globals, and constants are all roots
- **Configurable Thresholds**: Default 1024 allocations or 8MB estimated memory
- **Memory Estimation**: Tracks approximate bytes for lists, dicts, functions, etc.
- **Statistics Tracking**: Total bytes freed, collection count available via `__heap_stats__()`
- **Manual Trigger**: `__gc__()` builtin for explicit collection

### Memory Management

- **Arena-Based Heap**: Separate `DenseSlotMap` arenas for lists, tuples, dicts, functions, iterators, structs
- **String Interning**: All strings stored once via `strena::Interner`
- **Generation-Indexed Keys**: Type-safe references prevent use-after-free
- **Copy-on-Write Semantics**: Values are small (key-based), heap data shared until modified

## Development

### Running Tests

```bash
# Run test suite
./scripts/run-tests.sh

# Run benchmarks (Python vs Walrus comparison)
cd benchmarks && ./run_benchmarks.sh
```

### Building Optimized

```bash
# Release build
./scripts/build-optimized.sh

# Platform-specific
./scripts/build-linux-optimized.sh
./scripts/build-windows-optimized.sh
```

### Profiling

```bash
# Memory profiling with dhat
./scripts/dhat.sh

# CPU profiling (macOS)
./scripts/instruments.sh
```

## Examples

Check out the `showcase.walrus` file for a comprehensive demonstration of all language features, including:

- Bank account system
- Game character battles
- Prime number generation
- Text processing and palindromes
- Mathematical sequences
- Higher-order functions

Run it with:

```bash
cargo run -- showcase.walrus
```

## ü§ù Contributing

Contributions are welcome! Areas of interest:

- Standard library expansion
- Performance optimizations
- Additional language features
- Documentation improvements

Please check our [issue tracker](https://github.com/sb2bg/walrus/issues) for open tasks.

## üìú License

Walrus is licensed under the MIT License. See [LICENSE](LICENSE) for details.

## üôè Acknowledgments

Built with:

- [LALRPOP](https://github.com/lalrpop/lalrpop) - Parser generator
- [Cranelift](https://cranelift.dev/) - Native code generation for JIT compilation
- [SlotMap](https://github.com/orlp/slotmap) - Arena-based memory management
- [mimalloc](https://github.com/microsoft/mimalloc) - High-performance allocator
- [rustc-hash](https://github.com/rust-lang/rustc-hash) - Fast hashing (FxHashMap/FxHashSet)
- [strena](https://github.com/Kixiron/strena) - String interning
- [float-ord](https://github.com/notriddle/rust-float-ord) - Orderable floats for hash maps

---

**Happy Coding with Walrus! ü¶≠**
