# ü¶≠ Walrus Programming Language

A fast, expressive programming language with a clean syntax and powerful features, built in Rust.

## ‚ú® Overview

Walrus is a dynamically-typed, interpreted programming language that combines simplicity with power. It features both a tree-walking interpreter and a **bytecode virtual machine** for efficient execution, along with comprehensive support for modern programming paradigms.

## üöÄ Key Features

### Dual Execution Modes

- **Bytecode VM**: High-performance bytecode compiler and virtual machine with optimized instruction set
- **Tree-Walking Interpreter**: Direct AST interpretation for development and debugging
- **Disassembler**: Inspect generated bytecode and analyze program structure

### Language Features

- **First-Class Functions**: Functions as values, closures, and higher-order functions
- **Structs & Methods**: Object-oriented programming with struct definitions and method calls
- **Comprehensive Data Types**: integers, floats, strings, booleans, lists, dictionaries, ranges
- **Control Flow**: if/else conditionals, while loops, for loops with iterators
- **Pattern Matching**: Advanced conditional logic and type checking
- **Short-Circuit Evaluation**: Optimized boolean logic with `and`/`or` operators
- **Recursion**: Full support for recursive functions and algorithms
- **String Manipulation**: Slicing, indexing, and string operations
- **Collection Operations**: List concatenation, dictionary access, negative indexing

### Performance Optimizations

- **Specialized Opcodes**: Zero-operand instructions for common operations (LoadConst0, LoadLocal0, etc.)
- **Stack Manipulation**: Efficient Dup, Swap, Pop2, Pop3 operations
- **Memory-Optimized**: u32 indices reduce bytecode size from 16 to 12 bytes per instruction
- **Arena Allocation**: Custom memory management with `slotmap` for heap values
- **Custom Allocator**: Uses `mimalloc` for improved allocation performance

### Developer Experience

- **REPL Mode**: Interactive shell for rapid prototyping
- **Debugger Support**: Breakpoints, step-through execution, and stack inspection
- **Comprehensive Error Messages**: Detailed error reporting with source locations
- **Test Suite**: Extensive test coverage with 30+ test files

## üì¶ Installation

### Prerequisites

- [Rust](https://www.rust-lang.org/tools/install) (latest stable version)

### Build from Source

```bash
git clone https://github.com/sb2bg/walrus.git
cd walrus
cargo build --release
```

### Run

```bash
# Execute a file
cargo run -- file.walrus

# Start REPL
cargo run

# Compile mode (VM execution)
cargo run -- -c file.walrus

# Disassemble bytecode
cargo run -- -d file.walrus

# View help
cargo run -- --help
```

## üìö Quick Start

### Hello World

```walrus
println("Hello, World!");
```

### Variables & Types

```walrus
let number = 42;
let pi = 3.14159;
let name = "Walrus";
let active = true;
let items = [1, 2, 3, 4, 5];
let data = {"key": "value", "count": 10};
```

### Functions

```walrus
fn factorial : n {
    if n <= 1 {
        return 1;
    }
    return n * factorial(n - 1);
}

let result = factorial(5);  // 120
```

### Anonymous Functions

```walrus
let square = : x {
    return x * x;
};

let result = square(7);  // 49
```

### Structs

```walrus
struct Point {
    fn new : x, y {
        return {"x": x, "y": y};
    }

    fn distance : p1, p2 {
        let dx = p1["x"] - p2["x"];
        let dy = p1["y"] - p2["y"];
        return (dx * dx + dy * dy) ** 0.5;
    }
}

let p1 = Point.new(3, 4);
let p2 = Point.new(0, 0);
let dist = Point.distance(p1, p2);  // 5.0
```

### Control Flow

```walrus
// Conditionals
if score >= 90 {
    println("A");
} else if score >= 80 {
    println("B");
} else {
    println("C");
}

// While loop
let i = 0;
while i < 5 {
    println(i);
    i = i + 1;
}

// For loop with range
for x in 0..10 {
    println(x);
}

// For loop with list
for item in [1, 2, 3, 4, 5] {
    println(item);
}
```

### FizzBuzz Example

```walrus
for n in 1..101 {
    let result = "";

    if n % 3 == 0 {
        result += "Fizz";
    }

    if n % 5 == 0 {
        result += "Buzz";
    }

    if result == "" {
        result = n;
    }

    println(result);
}
```

### Quicksort Example

```walrus
fn quicksort : arr {
    if len(arr) <= 1 {
        return arr;
    }

    let pivot = arr[0];
    let less = [];
    let equal = [];
    let greater = [];

    for x in arr {
        if x < pivot {
            less = less + [x];
        } else if x == pivot {
            equal = equal + [x];
        } else {
            greater = greater + [x];
        }
    }

    return quicksort(less) + equal + quicksort(greater);
}

let sorted = quicksort([64, 34, 25, 12, 22, 11, 90, 88]);
```

## üèóÔ∏è Architecture

### Virtual Machine

The Walrus VM is a stack-based bytecode interpreter with:

- **70+ Opcodes**: Comprehensive instruction set for all language features
- **Constant Pool**: Efficient storage for literals and heap-allocated values
- **Symbol Tables**: Local and global variable management
- **Shared Globals**: Functions share global scope via `Rc<RefCell<>>`
- **Stack-Based Execution**: Fast push/pop operations with bounds checking

### Bytecode Compiler

- **Single-Pass Compilation**: Efficient AST to bytecode transformation
- **Jump Patching**: Forward references for control flow
- **Loop Context Tracking**: Break/continue support with proper cleanup
- **Scope Management**: Depth tracking for local vs. global variables
- **Function Compilation**: Nested instruction sets for closures

### Memory Management

- **Arena-Based Heap**: Separate arenas for strings, lists, dictionaries, functions, structs
- **SlotMap Storage**: Type-safe, generation-indexed heap allocations
- **String Interning**: Via `strena` for efficient string storage
- **Copy-on-Write**: Value semantics with efficient heap references

## üîß Development

### Running Tests

# Run with scripts

./scripts/run-tests.sh

````

### Building Optimized

```bash
# Release build
./scripts/build-optimized.sh

# Platform-specific
./scripts/build-linux-optimized.sh
./scripts/build-windows-optimized.sh
````

### Profiling

```bash
# Memory profiling with dhat
./scripts/dhat.sh

# CPU profiling (macOS)
./scripts/instruments.sh
```

## üìÑ Examples

Check out the `showcase.walrus` file for a comprehensive demonstration of all language features, including:

- Bank account system
- Game character battles
- Prime number generation
- Text processing and palindromes
- Mathematical sequences
- Higher-order functions

Run it with:

```bash
cargo run -- showcase.walrus
```

## ü§ù Contributing

Contributions are welcome! Areas of interest:

- Standard library expansion
- Performance optimizations
- Additional language features
- Documentation improvements

Please check our [issue tracker](https://github.com/sb2bg/walrus/issues) for open tasks.

## üìú License

Walrus is licensed under the MIT License. See [LICENSE](LICENSE) for details.

## üôè Acknowledgments

Built with:

- [LALRPOP](https://github.com/lalrpop/lalrpop) - Parser generator
- [SlotMap](https://github.com/orlp/slotmap) - Memory management
- [mimalloc](https://github.com/microsoft/mimalloc) - High-performance allocator
- [rustc-hash](https://github.com/rust-lang/rustc-hash) - Fast hashing

---

**Happy Coding with Walrus! ü¶≠**
