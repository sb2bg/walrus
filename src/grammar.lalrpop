use crate::ast::{Node, NodeKind, Op};
use crate::span::{Span, Spanned};
use float_ord::FloatOrd;
use crate::error::{RecoveredParseError, parse_int, parse_float};

grammar;

extern {
    type Error = RecoveredParseError;
}

pub Program = Statement;

Statement: Box<Node> = {
    Sp<DelimTrailing<Expr, ";">> => Box::new(Node::new(NodeKind::Statement(<>.value), <>.span)),
};

BinOp<Op, Next>: Box<Node> = {
    <l: @L> <left: BinOp<Op, Next>> <o: Op> <right: Next> <r: @R> => Box::new(Node::new(NodeKind::BinOp(left, o, right), Span(l, r))),
    Next
};

Expr: Box<Node> = BinOp<ExprOp, Factor>;

Factor: Box<Node> = BinOp<FactorOp, Term>;

ExprOp: Op = {
    "+" => Op::Add,
    "-" => Op::Sub,
};

FactorOp: Op = {
    "*" => Op::Mul,
    "/" => Op::Div,
};

Term: Box<Node> = {
    Int => Box::new(Node::new(NodeKind::Int(<>.value), <>.span)),
    Float => Box::new(Node::new(NodeKind::Float(FloatOrd(<>.value)), <>.span)),
    Sp<String> => Box::new(Node::new(NodeKind::String(<>.value), <>.span)),
    Sp<List> => Box::new(Node::new(NodeKind::List(<>.value), <>.span)),
    Sp<Dict> => Box::new(Node::new(NodeKind::Dict(<>.value), <>.span)),
    Sp<Ident> => Box::new(Node::new(NodeKind::Ident(<>.value), <>.span)),
    Sp<Bool> => Box::new(Node::new(NodeKind::Bool(<>.value), <>.span)),
    // todo: check if Function and AnonFunction should be an atomic expression
    Sp<Function> => Box::new(Node::new(NodeKind::FunctionDefinition(<>.value.0, <>.value.1, <>.value.2), <>.span)),
    Sp<AnonFunction> => Box::new(Node::new(NodeKind::AnonFunctionDefinition(<>.value.0, <>.value.1), <>.span)),
//    Sp<Assignment> => Box::new(Node::new(NodeKind::Assign(<>.value.0, <>.value.1), <>.span)),
//    Sp<Return> => Box::new(Node::new(NodeKind::Return(<>.value), <>.span)),
    Sp<"void"> => Box::new(Node::new(NodeKind::Void, <>.span)),
    "(" <Expr> ")"
};

Int: Spanned<i64> = {
    Sp<r"\d+"> =>? parse_int(<>, 10),
    Sp<r"0x[0-9A-Fa-f]+"> =>? parse_int(<>, 16),
    Sp<r"0o[0-7]+"> =>? parse_int(<>, 8),
    Sp<r"0b[01]+"> =>? parse_int(<>, 2),
};

Float: Spanned<f64> = {
    Sp<r"\d+\.\d+"> =>? parse_float(<>),
};

String: String = {
    r#""[^"]*""# => <>[1..<>.len() - 1].to_string(),
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

Ident: String = {
   r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string(),
};

List = Bracket<Comma<Expr>>;

Dict = Brace<Comma<InnerDict>>;
InnerDict = <Expr> ":" <Expr>;

AnonFunction: (Vec<String>, Box<Node>) = {
//    "fn" <a: Paren<Comma<Ident>>> <b: Expr> => (a, b), this causes build step to fail but idk why
    "fn" <a: Paren<Comma<Ident>>> <b: Block> => (a, b),
};

Function: (String, Vec<String>, Box<Node>) = {
    "fn" <n: Ident> <a: Paren<Comma<Ident>>> <b: Block> => (n, a, b),
};

Assignment: (String, Box<Node>) = {
    "let" <id: Ident> "=" <e: Expr> => (id, e),
};

Return: Box<Node> = {
    "return" <Expr>,
};

Brace<T> = "{" <T> "}";
Bracket<T> = "[" <T> "]";
Paren<T> = "(" <T> ")";
Comma<T> = Delim<T, ",">;
Block = Brace<Statement>;

Sp<Rule>: Spanned<Rule> = <l: @L> <rule: Rule> <r: @R> => Spanned { value: rule, span: Span(l, r) };

Delim<T, D>: Vec<T> = {
    <mut h: (<T> D)*> <t: T?> => match t {
        Some(t) => {
            h.push(t);
            h
        }
        None => h
    }
};

DelimTrailing<T, D>: Vec<T> = {
    <mut h: (<T> D)*> <t: T> D => {
        h.push(t);
        h
    }
};