use crate::ast::{Node, NodeKind, Op};
use crate::span::Span;
use crate::error::{RecoveredParseError, parse_int, parse_float};

grammar;

extern {
    type Error = RecoveredParseError;
}

pub Program = Sp<Statements>;

Statements: NodeKind = {
    TrailingDelim<Statement, ";"> => NodeKind::Statements(<>),
    => NodeKind::Void
}

Statement: Box<Node> = {
    Sp<If>,
    Sp<For>,
    Sp<While>,
    Sp<Expr>,
    Sp<Func>,
    Sp<Extern>,
    Sp<Assign>,
    Sp<Return>,
    Sp<Break>,
    Sp<Continue>,
    Sp<Import>,
    Sp<Print>,
    Sp<Throw>,
};

BinOp<Op, Next>: NodeKind = {
    <left: Sp<BinOp<Op, Next>>> <o: Op> <right: Sp<Next>> => NodeKind::BinOp(left, o, right),
    Next,
};

Expr: NodeKind = BinOp<ExprOp, Factor>;
Factor: NodeKind = BinOp<FactorOp, Term>;

ExprOp: Op = {
    "+" => Op::Add,
    "-" => Op::Sub,
};

FactorOp: Op = {
    "*" => Op::Mul,
    "/" => Op::Div,
};

Term: NodeKind = {
    Int,
    Float,
	String,
	Bool,
	Ident,
	List,
	Dict,
	Paren<Expr>,
};

// todo: maybe add range syntax

Int: NodeKind = {
    StrSp<r"\d+"> =>? parse_int(<>, 10),
    StrSp<r"0x[0-9A-Fa-f]+"> =>? parse_int(<>, 16),
    StrSp<r"0o[0-7]+"> =>? parse_int(<>, 8),
    StrSp<r"0b[01]+"> =>? parse_int(<>, 2),
};

Float: NodeKind = {
    StrSp<r"\d+\.\d+"> =>? parse_float(<>),
};

String: NodeKind = {
	r#""[^"]*""# => NodeKind::String(<>[1..<>.len() - 1].to_string()),
};

Bool: NodeKind = {
	"true" => NodeKind::Bool(true),
	"false" => NodeKind::Bool(false),
};

List: NodeKind = {
    Bracket<Comma<Sp<Expr>>> => NodeKind::List(<>),
};

Dict: NodeKind = {
    Brace<Comma<DictEntry>> => NodeKind::Dict(<>),
};

DictEntry = <Sp<Expr>> ":" <Sp<Expr>>;

Ident: NodeKind = {
	IdentStr => NodeKind::Ident(<>),
};

IdentStr: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();

If: NodeKind = "if" <c: Sp<Expr>> <b: Sp<Block>> <e: Else> => NodeKind::If(c, b, e);

Else: Option<Box<Node>> = {
	"else" <Sp<Block>> => Some(<>),
	"else" <Sp<If>> => Some(<>),
	=> None,
};

While: NodeKind = {
    "while" <c: Sp<Expr>> <b: Sp<Block>> => NodeKind::While(c, b),
};

For: NodeKind = {
    // var, iter, body
    // for var in iter { body }
    "for" <v: Sp<Ident>> "in" <i: Sp<Expr>> <b: Sp<Block>> => NodeKind::For(v, i, b),
};

Func: NodeKind = {
    "fn" <n: IdentStr> <a: Paren<Comma<IdentStr>>> <b: Sp<Block>> => NodeKind::FunctionDefinition(n, a, b),
    "fn" <a: Paren<Comma<IdentStr>>> <b: Sp<Block>> => NodeKind::AnonFunctionDefinition(a, b),
};

Extern: NodeKind = {
    "extern" <n: IdentStr> <a: Paren<Comma<IdentStr>>> => NodeKind::ExternFunctionDefinition(n, a),
};

Assign: NodeKind = {
    "let" <n: IdentStr> "=" <e: Sp<Expr>> => NodeKind::Assign(n, e),
    <n: Sp<Ident>> "=" <e: Sp<Expr>> => NodeKind::Reassign(n, e, Op::Equal),
    <n: Sp<Ident>> "+=" <e: Sp<Expr>> => NodeKind::Reassign(n, e, Op::Add),
    <n: Sp<Ident>> "-=" <e: Sp<Expr>> => NodeKind::Reassign(n, e, Op::Sub),
    <n: Sp<Ident>> "*=" <e: Sp<Expr>> => NodeKind::Reassign(n, e, Op::Mul),
    <n: Sp<Ident>> "/=" <e: Sp<Expr>> => NodeKind::Reassign(n, e, Op::Div),
    <n: Sp<Ident>> "%=" <e: Sp<Expr>> => NodeKind::Reassign(n, e, Op::Mod),
    <n: Sp<Ident>> "**=" <e: Sp<Expr>> => NodeKind::Reassign(n, e, Op::Pow),
};

Return: NodeKind = {
    "return" <e: Sp<Expr>> => NodeKind::Return(e),
};

Break: NodeKind = {
    "break" => NodeKind::Break,
};

Continue: NodeKind = {
    "continue" => NodeKind::Continue,
};

Import: NodeKind = {
    "import" <n: IdentStr> => NodeKind::Import(n),
};

Print: NodeKind = {
    "print" <e: Sp<Expr>> => NodeKind::Print(e),
};

Throw: NodeKind = {
    "throw" <e: Sp<Expr>> => NodeKind::Throw(e),
};

Block = Brace<Statements>;
Brace<T>: T = "{" <T> "}";
Paren<T>: T = "(" <T> ")";
Bracket<T>: T = "[" <T> "]";
Comma<T> = Delim<T, ",">;

Delim<T, D>: Vec<T> = {
    <mut h: (<T> D)*> <t: T?> => match t {
        Some(t) => {
            h.push(t);
            h
        }
        None => h
    }
};

TrailingDelim<T, D>: Vec<T> = {
    <mut h: (<T> D)*> <t: T> D => {
        h.push(t);
        h
    }
};

Sp<Rule>: Box<Node> = <l: @L> <rule: Rule> <r: @R> => Box::new(Node::new(rule, Span(l, r)));
StrSp<Rule>: (String, Span) = <l: @L> <rule: Rule> <r: @R> => (rule.to_string(), Span(l, r));