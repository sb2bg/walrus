struct Counter {
    fn init : self, limit {
        self.limit = limit;
        self.current = 0;
    }

    fn iter : self {
        // Python-style: return iterator object (self) and reset state.
        self.current = 0;
        return self;
    }

    fn next : self {
        if self.current >= self.limit {
            return void;
        }

        self.current = self.current + 1;
        return self.current;
    }
}

let counter = Counter(3);
let count = 0;
let sum = 0;

for value in counter {
    count += 1;
    sum += value;
}

println(f"count={count}");
println(f"sum={sum}");

// Second pass should still work because iter() resets current.
let count2 = 0;
for value in counter {
    count2 += 1;
}
println(f"count2={count2}");

struct NextOnly {
    fn init : self {
        self.value = 0;
    }

    fn next : self {
        if self.value >= 2 {
            return void;
        }
        self.value = self.value + 1;
        return self.value;
    }
}

let next_only = NextOnly();
let next_only_count = 0;
for value in next_only {
    next_only_count += 1;
}
println(f"next_only_count={next_only_count}");
